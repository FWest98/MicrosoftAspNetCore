<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <!-- Forcing the device width here so that our automated tests work consistently on mobile browsers. -->
    <meta name="viewport" content="width=1024">
    <title>Blazor standalone</title>
    <base href="/" />
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
    <link href="css/app.css" rel="stylesheet" />
</head>
<body>
    <app>Loading...</app>

    <div id="blazor-error-ui">
        An unhandled exception has occurred. See browser dev tools for details.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>

    <script src="_framework/blazor.webassembly.js" autostart="false"></script>
    <script>
        (function () {
            class BlazorCustomElement extends HTMLElement {
                constructor(parameterMappings) {
                    super();

                    this._parameterMappings = parameterMappings;
                    this._parameterValues = {};

                    // Defer until end of execution cycle so that (1) we know the heap is unlocked, and (2) the initial parameter
                    // values will be populated from the initial attributes before we send them to .NET
                    this._addRootComponentPromise = Promise.resolve().then(() => {
                        this._hasPendingSetParameters = false;
                        return Blazor.rootComponents.add(this, this.localName, this._parameterValues);
                    });

                    // The promise above will set parameters when it calls 'add'
                    this._hasPendingSetParameters = true;

                    // Also allow assignment of parameters via properties. This is the only way to set complex-typed values.
                    for (const [attributeName, dotNetName] of Object.entries(parameterMappings)) {
                        const camelCaseName = dotNetName[0].toLowerCase() + dotNetName.substr(1);
                        Object.defineProperty(this, camelCaseName, {
                            get: () => this._parameterValues[dotNetName],
                            set: newValue => {
                                if (this.hasAttribute(attributeName)) {
                                    // It's nice to keep the DOM in sync with the properties. This set a string representation
                                    // of the value, but this will get overwritten with the original typed value before we send it to .NET
                                    this.setAttribute(attributeName, newValue);
                                }

                                this._parameterValues[dotNetName] = newValue;
                                this._supplyUpdatedParameters();
                            }
                        });
                    }
                }

                connectedCallback() {
                    if (this._isDisposed) {
                        throw new Error(`Cannot connect component ${this.localName} to the document after it has been disposed.`);
                    }

                    clearTimeout(this._disposalTimeout);
                }

                disconnectedCallback() {
                    this._disposalTimeout = setTimeout(async () => {
                        this._isDisposed = true;
                        const rootComponent = await this._addRootComponentPromise;
                        rootComponent.dispose();
                    }, 1000);
                }

                attributeChangedCallback(name, oldValue, newValue) {
                    const dotNetName = this._parameterMappings[name];
                    if (dotNetName) {
                        this._parameterValues[dotNetName] = newValue;
                        this._supplyUpdatedParameters();
                    }
                }

                async _supplyUpdatedParameters() {
                    if (!this._hasPendingSetParameters) {
                        this._hasPendingSetParameters = true;

                        // Continuation from here will always be async, so at the earliest it will be at
                        // the end of the current JS execution cycle
                        const rootComponent = await this._addRootComponentPromise;
                        if (!this._isDisposed) {
                            const setParametersPromise = rootComponent.setParameters(this._parameterValues);
                            this._hasPendingSetParameters = false; // We just snapshotted _parameterValues, so we need to start allowing new calls in case it changes further
                            await setParametersPromise;
                        }
                    }
                }
            }

            Blazor._internal.registerCustomElement = function (name, parameters) {
                // TODO: Put some logic like this into the host code so that the parameter mappings
                // are communicated internally, not via constructor params.
                const parameterMappings = {};
                parameters.forEach(name => {
                    const dasherizedName = name.replace(/[A-Z]/g, (char, index) =>
                        (index ? '-' : '') + char.toLowerCase());
                    parameterMappings[dasherizedName] = name;
                });

                customElements.define(name, class MyCustomElement extends BlazorCustomElement {
                    static get observedAttributes() { return Object.keys(parameterMappings); }

                    constructor() {
                        super(parameterMappings);
                    }
                });
            };

            Blazor.start().then(function () {
                window['__aspnetcore__testing__blazor_wasm__started__'] = true;
            });
        })();
    </script>
</body>
</html>
