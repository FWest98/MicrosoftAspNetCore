<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <!-- Forcing the device width here so that our automated tests work consistently on mobile browsers. -->
    <meta name="viewport" content="width=1024">
    <title>Blazor standalone</title>
    <base href="/" />
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
    <link href="css/app.css" rel="stylesheet" />
</head>
<body>
    <app>Loading...</app>

    <div id="blazor-error-ui">
        An unhandled exception has occurred. See browser dev tools for details.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>

    <script src="_framework/blazor.webassembly.js" autostart="false"></script>
    <script>
        (function () {
            class BlazorCustomElement extends HTMLElement {
                constructor(parameterMappings) {
                    super();

                    this._parameterMappings = parameterMappings;
                    this._parameterValues = {};

                    // Defer until end of execution cycle to be sure the .NET heap is unlocked
                    this._addRootComponentPromise = Promise.resolve().then(() => {
                        this._hasPendingSetParameters = false;
                        return Blazor.rootComponents.add(this, this.localName, this._parameterValues);
                    });

                    // The promise above will set parameters when it calls 'add'
                    this._hasPendingSetParameters = true;

                    // TODO: Register JS properties with setters that trigger updates
                }

                connectedCallback() {
                    if (this._isDisposed) {
                        throw new Error(`Cannot connect component ${this.localName} to the document after it has been disposed.`);
                    }

                    clearTimeout(this._disposalTimeout);
                }

                disconnectedCallback() {
                    this._disposalTimeout = setTimeout(async () => {
                        this._isDisposed = true;
                        const rootComponent = await this._addRootComponentPromise;
                        rootComponent.dispose();
                    }, 1000);
                }

                attributeChangedCallback(name, oldValue, newValue) {
                    const mapping = this._parameterMappings[name];
                    if (mapping) {
                        this._parameterValues[mapping.name] = BlazorCustomElement.convertToType(newValue, mapping.type, mapping.name);
                        this._supplyUpdatedParameters();
                    }
                }

                async _supplyUpdatedParameters() {
                    if (!this._hasPendingSetParameters) {
                        this._hasPendingSetParameters = true;

                        // Continuation from here will always be async, so at the earliest it will be at
                        // the end of the current JS execution cycle
                        const rootComponent = await this._addRootComponentPromise;
                        if (!this._isDisposed) {
                            const setParametersPromise = rootComponent.setParameters(this._parameterValues);
                            this._hasPendingSetParameters = false; // We just snapshotted _parameterValues, so we need to start allowing new calls in case it changes further
                            await setParametersPromise;
                        }
                    }
                }

                static convertToType(stringValue, type, parameterName) {
                    switch (type) {
                        case 'string':
                            return stringValue;
                        case 'boolean':
                            switch (stringValue) {
                                case 'true':
                                case 'True':
                                    return true;
                                case 'false':
                                case 'False':
                                    return false;
                                default:
                                    throw new Error(`Invalid boolean value '${stringValue}' for parameter '${parameterName}'`);
                            }
                        case 'number':
                            const number = Number(stringValue);
                            if (Number.isNaN(number)) {
                                throw new Error(`Invalid number value '${stringValue}' for parameter '${parameterName}'`);
                            } else {
                                return number;
                            }
                        case 'boolean?':
                            return stringValue ? BlazorCustomElement.convertToType(stringValue, 'boolean') : null;
                        case 'number?':
                            return stringValue ? BlazorCustomElement.convertToType(stringValue, 'number') : null;
                        case 'object':
                            throw new Error(`The parameter '${parameterName}' is a complex-typed object so it cannot be set using an attribute. Try setting it as a element property instead.`);
                        default:
                            throw new Error(`Unknown type '${type}' for parameter '${parameterName}'`);
                    }
                }
            }

            Blazor._internal.registerCustomElement = function (name, parameters) {
                // TODO: Put some logic like this into the host code so that the parameter mappings
                // are communicated internally, not via constructor params.
                const parameterMappings = {};
                parameters.forEach(parameter => {
                    const dasherizedName = parameter.name.replace(/[A-Z]/g, (char, index) =>
                        (index ? '-' : '') + char.toLowerCase());
                    parameterMappings[dasherizedName] = parameter;
                });

                customElements.define(name, class MyCustomElement extends BlazorCustomElement {
                    static get observedAttributes() { return Object.keys(parameterMappings); }

                    constructor() {
                        super(parameterMappings);
                    }
                });
            };

            Blazor.start().then(function () {
                window['__aspnetcore__testing__blazor_wasm__started__'] = true;
            });
        })();
    </script>
</body>
</html>
